@model EquationsSystemSolverByGaussianElimination
@inject IOptions<MathFormatOptions> mathFormatOptions
@{
    ViewData["Title"] = "Решение системы уравнений";
    int precision = mathFormatOptions.Value.DecimalPrecision;
    double epsilon = Math.Pow(0.1, precision);
}

<h1>Решение системы уравнений (метод Гаусса)</h1>
<p><math><math-equation-system a="Model.A" b="Model.B" /></math></p>

<p>
    @if (Model.X.ColumnCount == 0)
    {
        @:Нет решений.
    }
    else
    {
        for (int i = 0; i < Model.X.RowCount; i++)
        {
            <math>
                <msub><mi>x</mi><mn>@(i + 1)</mn></msub>
                <mo>=</mo>
                @{
                    await RenderPolynomial(Model.X.Row(i), precision);
                }
            </math>@(i < Model.X.RowCount - 1 ? "," : ".")
        }
    }
</p>

<p>Подробное решение:</p>
<ol>
    <li>
        <p>
            Построим расширенную матрицу <math><mi>A|B</mi></math>:
        </p>
        <p>
            <math>
                <mrow>
                    <mo>(</mo>
                    <math-matrix data="Model.GaussianElimination.Initial" precision="precision" />
                    <mo>)</mo>
                </mrow>
            </math>
        </p>
    </li>
    @await Html.PartialAsync("_GaussianElimination", Model.GaussianElimination)
    @{
        int aMatrixRank = Model.A.Rank();
        int augmentedMatrixRank = Model.GaussianElimination.Result.Rank();

        <li>
            <p>
                По полученной матрице найдем ранги матрицы <math><mi>A</mi></math> и расширенной матрицы
                <math><mi>A|B</mi></math> (ранг матрицы равен количеству ненулевых строк):
            </p>
            <p>
                <math><mi>rangA</mi><mo>=</mo><mn>@aMatrixRank</mn></math>
            </p>
            <p>
                <math><mi>rangA|B</mi><mo>=</mo><mn>@augmentedMatrixRank</mn></math>
            </p>
        </li>

        if (aMatrixRank != augmentedMatrixRank)
        {
            <li>
                <p>
                    Ранг матрицы <math><mi>A</mi></math> и ранг расширенной матрицы не равны, следовательно, система
                    уравнений не имеет решений.
                </p>
            </li>
        }
        else if (aMatrixRank == Model.A.ColumnCount)
        {
            <li>
                <p>
                    Ранг матрицы <math><mi>A</mi></math> и ранг расширенной матрицы равны количеству переменных,
                    следовательно, система уравнений имеет единственное решение.
                </p>
            </li>
            <li>
                <p>Вычислим значения переменных:</p>
                @{
                    await RenderBasicVariablesCalculation(
                        Model,
                        Enumerable.Range(0, Model.X.RowCount).ToList(),
                        precision);
                }
            </li>
        }
        else
        {
            <li>
                <p>
                    Ранг матрицы <math><mi>A</mi></math> и ранг расширенной матрицы равны, но не равны количеству
                    переменных, следовательно, система уравнений имеет множество решений.
                </p>
            </li>
            <li>
                <p>
                    Выпишем свободные переменные:
                </p>
                    @foreach(var i in Model.FreeVariablesIndices)
                    {
                        <p>
                            <math>
                                <msub><mi>x</mi><mn>@(i + 1)</mn></msub>
                                <mo>=</mo>
                                @{
                                    await RenderPolynomial(Model.X.Row(i), precision);
                                }
                            </math>
                        </p>
                    }
            </li>
            <li>
                <p>Выразим базисные переменные через свободные:</p>
                @{
                    await RenderBasicVariablesCalculation(
                        Model,
                        Model.BasicVariablesIndices,
                        precision);
                }
            </li>
        }
    }
</ol>

@section Scripts
{
    <partial name="_GlobalizationScripts" />
}

@functions
{
    public int GetTermsCount(List<double> a, Matrix<double> x, double epsilon)
    {
        int result = 0;

        for (int i = 0; i < a.Count; i++)
        {
            if (!MathUtils.AreEqual(a[i], 0, epsilon) &&
                x.Row(i).Any(coeff => !MathUtils.AreEqual(coeff, 0, epsilon)))
            {
                result++;
            }
        }

        if (result == 0)
        {
            // The only once term is zero
            result++;
        }

        return result;
    }

    public int GetMaxTermLength(List<double> a, Matrix<double> x, double epsilon)
    {
        int maxTermLength = 0;

        for (int i = 0; i < a.Count; i++)
        {
            if (!MathUtils.AreEqual(a[i], 0, epsilon))
            {
                int termLength =
                    x.Row(i).Count(coeff => !MathUtils.AreEqual(coeff, 0, epsilon));

                if (termLength > maxTermLength)
                {
                    maxTermLength = termLength;
                }
            }
        }

        if (maxTermLength == 0)
        {
            // The only once term is zero
            maxTermLength++;
        }

        return maxTermLength;
    }

    public async Task RenderPolynomial(Vector<double> coefficients, int precision)
    {
        double epsilon = Math.Pow(0.1, precision);

        if (coefficients.Any(c => !MathUtils.AreEqual(c, 0, epsilon)))
        {
            bool isFirst = true;

            for (int i = 0; i < coefficients.Count; i++)
            {
                if (!MathUtils.AreEqual(coefficients[i], 0, epsilon))
                {
                    double coefficient = 0.0;

                    if (isFirst)
                    {
                        isFirst = false;
                        coefficient = coefficients[i];
                    }
                    else
                    {
                        <mo>@(coefficients[i] > 0 ? "+" : "-")</mo>
                        coefficient = Math.Abs(coefficients[i]);
                    }

                    if (i == 0)
                    {
                        <math-number value="coefficient" precision="precision" />
                    }
                    else
                    {
                        if (!MathUtils.AreEqual(coefficient, 1, epsilon))
                        {
                            <math-number value="coefficient" precision="precision" />
                        }

                        <msub><mi>c</mi><mn>@i</mn></msub>
                    }
                }
            }
        }
        else
        {
            <mn>0</mn>
        }
    }

    public async Task RenderPolynomialsSum(
        List<double> coefficients,
        Matrix<double> polynomials,
        int precision)
    {
        double epsilon = Math.Pow(0.1, precision);
        bool isFirst = true;

        for (int i = 0; i < coefficients.Count; i++)
        {
            int nonZeroTermsCount =
                polynomials.Row(i).Count(x => !MathUtils.AreEqual(x, 0, epsilon));

            if (!MathUtils.AreEqual(coefficients[i], 0, epsilon) && (nonZeroTermsCount > 0))
            {
                if (isFirst)
                {
                    isFirst = false;
                }
                else
                {
                    <mo>+</mo>
                }

                if (!MathUtils.AreEqual(coefficients[i], 1, epsilon))
                {
                    <math-number value="coefficients[i]" precision="precision" use-brackets="true" />
                    <mo>&sdot;</mo>
                }


                // Sum of multiple terms or negative constant
                bool useBrackets = ((nonZeroTermsCount > 1) || (polynomials.Row(i)[0] < 0));

                if (useBrackets)
                {
                    <mo>(</mo>
                }

                await RenderPolynomial(polynomials.Row(i), precision);

                if (useBrackets)
                {
                    <mo>)</mo>
                }
            }
        }
    }

    public async Task RenderBasicVariablesCalculation(
        EquationsSystemSolverByGaussianElimination solver,
        List<int> basicVariablesIndices,
        int precision)
    {
        double epsilon = Math.Pow(0.1, precision);

        for (int i = basicVariablesIndices.Count - 1; i >= 0; i--)
        {
            int j = basicVariablesIndices[i];

            <p>
                <math>
                    <msub><mi>x</mi><mn>@(j + 1)</mn></msub>
                    <mo>=</mo>
                    @{
                        var a = new List<double>();
                        var x = Matrix<double>.Build.Dense(1, solver.X.ColumnCount);

                        a.Add(1);
                        x[0, 0] = solver.GaussianElimination.Result.Row(i).Last();

                        a.AddRange(solver.GaussianElimination.Result.Row(i)
                            .SubVector(j + 1, solver.A.ColumnCount - j - 1)
                            .Select(coeff => -coeff));
                        x = x.Stack(solver.X.SubMatrix(
                            j + 1,
                            solver.A.ColumnCount - j - 1,
                            0,
                            solver.X.ColumnCount));

                        int termsCount = GetTermsCount(a, x, epsilon);
                        int maxTermLength = GetMaxTermLength(a, x, epsilon);
                        double denominator = solver.GaussianElimination.Result[i, j];

                        if ((termsCount > 1) || !MathUtils.AreEqual(denominator, 1, epsilon))
                        {
                            bool useBrackets = !MathUtils.AreEqual(denominator, 1, epsilon) &&
                                ((termsCount > 1) || (maxTermLength > 1));

                            if (useBrackets)
                            {
                                <mo>(</mo>
                            }

                            await RenderPolynomialsSum(a, x, precision);

                            if (useBrackets)
                            {
                                <mo>)</mo>
                            }

                            if (!MathUtils.AreEqual(denominator, 1, epsilon))
                            {
                                <mo>&sdot;</mo>
                                <mfrac>
                                    <mn>1</mn>
                                    <math-number value="denominator" precision="precision" />
                                </mfrac>
                            }

                            <mo>=</mo>
                        }

                        await RenderPolynomial(solver.X.Row(j), precision);
                    }
                </math>
            </p>
        }
    }
}